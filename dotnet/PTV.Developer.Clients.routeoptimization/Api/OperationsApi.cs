/*
 * Route Optimization
 *
 * With the Route Optimization service you can schedule and optimize the routes of your fleet.
 *
 * The version of the OpenAPI document: 1.8
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using PTV.Developer.Clients.routeoptimization.Client;
using PTV.Developer.Clients.routeoptimization.Model;

namespace PTV.Developer.Clients.routeoptimization.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IOperationsApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Cancels the current operation of a plan. After cancelling an operation, the operation status for this plan can no longer be retrieved.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routeoptimization.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the plan which corresponding operation should be cancelled.</param>
        /// <returns></returns>
        void CancelOperation(Guid id);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Cancels the current operation of a plan. After cancelling an operation, the operation status for this plan can no longer be retrieved.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routeoptimization.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the plan which corresponding operation should be cancelled.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> CancelOperationWithHttpInfo(Guid id);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Retrieves the status of the current operation that is executed for the plan. If currently no operation is executed the status of the last executed operation is returned.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routeoptimization.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the plan for which the corresponding operation status should be requested.</param>
        /// <returns>Operation</returns>
        Operation GetOperationStatus(Guid id);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Retrieves the status of the current operation that is executed for the plan. If currently no operation is executed the status of the last executed operation is returned.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routeoptimization.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the plan for which the corresponding operation status should be requested.</param>
        /// <returns>ApiResponse of Operation</returns>
        ApiResponse<Operation> GetOperationStatusWithHttpInfo(Guid id);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Starts an asynchronous evaluation of the specified plan. Only one operation can be started for a plan at a time. Trying to start another operation before the current operation is finished results in an error. Whether an operation is finished or not can be checked with \&quot;getOperationStatus\&quot;. To get the result after the operation is finished \&quot;getPlan\&quot; can be used. Evaluation of a plan calculates driving times, service times, break and rest times and waiting times taking into account given time intervals. It may happen that not all restrictions can be fullfilled in which case one or more violations are reported. Evaluation does not change which transports are scheduled into which route nor their sequence, it does also not change the assignments of routes to vehicles.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routeoptimization.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the plan to be evaluated.</param>
        /// <returns></returns>
        void StartEvaluation(Guid id);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Starts an asynchronous evaluation of the specified plan. Only one operation can be started for a plan at a time. Trying to start another operation before the current operation is finished results in an error. Whether an operation is finished or not can be checked with \&quot;getOperationStatus\&quot;. To get the result after the operation is finished \&quot;getPlan\&quot; can be used. Evaluation of a plan calculates driving times, service times, break and rest times and waiting times taking into account given time intervals. It may happen that not all restrictions can be fullfilled in which case one or more violations are reported. Evaluation does not change which transports are scheduled into which route nor their sequence, it does also not change the assignments of routes to vehicles.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routeoptimization.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the plan to be evaluated.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> StartEvaluationWithHttpInfo(Guid id);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Starts an asynchronous optimization of the specified plan. Only one operation can be started for a plan at a time. Trying to start another operation before the current operation is finished results in an error. Whether an operation is finished or not can be checked with \&quot;getOperationStatus\&quot;. To get the result after the operation is finished \&quot;getPlan\&quot; can be used. In the optimized plan, routes ideally include all transports that are specified in the request. Routes have additional information like arrival and departure times, driving times, service times and more.  If you call startOptimization multiple times consecutively for the same id, the optimization uses the result of the previous optimization as input, so previously planned transports remain planned in the output routes. If this is not what you intend to do, you can create a new plan before another startOptimization call.  When starting the optimization, the number of transports in the plan is used to calculate the number of transactions, see [here](../../help/faq-help) for more information.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routeoptimization.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the plan to be optimized.</param>
        /// <param name="quality">The optimization quality defines the tradeoff between calculation time and quality. A high solution quality and a low calculation time are conflicting. A larger solution search space may lead to a better solution but will take more calculation time.   * &#x60;STANDARD&#x60; - This quality level represents a good trade-off between solution quality and calculation time.   * &#x60;HIGH&#x60; - On this quality level, the search space is larger than on the standard level. This may lead to a better solution but will take more calculation time. (optional)</param>
        /// <param name="tweaksToObjective">A tweak to objective defines additional optimization criteria. Without any tweak, the standard optimization goal is to plan as many transports as possible with as few vehicles as possible.   * &#x60;AVOID_INTERSECTIONS&#x60; - The focus of this approach is to avoid intersections of edges, where an edge is a straight line drawn between two consecutive stops in a route. The number of routes may be higher compared to the standard optimization goal.   * &#x60;IGNORE_MINIMIZATION_OF_NUMBER_OF_ROUTES&#x60; - With this tweak, the number of vehicles used in a plan, and thus the number of routes, is not minimized. (optional)</param>
        /// <param name="considerTransportPriorities">Set transport priority consideration to true or false.  See [here](./concepts/transport-priorities) for more information. (optional, default to false)</param>
        /// <param name="optimizationPremium">Set Optimization Premium to true to boost quality of results for all **quality** modes by taking advantage of additional computational resources.  Transactions&#39; packages for Optimization Premium are calculated differently.  See [here](./concepts/optimization-premium) for more information. (optional, default to false)</param>
        /// <returns></returns>
        void StartOptimization(Guid id, OptimizationQuality? quality = default(OptimizationQuality?), List<TweakToObjective> tweaksToObjective = default(List<TweakToObjective>), bool? considerTransportPriorities = default(bool?), bool? optimizationPremium = default(bool?));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Starts an asynchronous optimization of the specified plan. Only one operation can be started for a plan at a time. Trying to start another operation before the current operation is finished results in an error. Whether an operation is finished or not can be checked with \&quot;getOperationStatus\&quot;. To get the result after the operation is finished \&quot;getPlan\&quot; can be used. In the optimized plan, routes ideally include all transports that are specified in the request. Routes have additional information like arrival and departure times, driving times, service times and more.  If you call startOptimization multiple times consecutively for the same id, the optimization uses the result of the previous optimization as input, so previously planned transports remain planned in the output routes. If this is not what you intend to do, you can create a new plan before another startOptimization call.  When starting the optimization, the number of transports in the plan is used to calculate the number of transactions, see [here](../../help/faq-help) for more information.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routeoptimization.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the plan to be optimized.</param>
        /// <param name="quality">The optimization quality defines the tradeoff between calculation time and quality. A high solution quality and a low calculation time are conflicting. A larger solution search space may lead to a better solution but will take more calculation time.   * &#x60;STANDARD&#x60; - This quality level represents a good trade-off between solution quality and calculation time.   * &#x60;HIGH&#x60; - On this quality level, the search space is larger than on the standard level. This may lead to a better solution but will take more calculation time. (optional)</param>
        /// <param name="tweaksToObjective">A tweak to objective defines additional optimization criteria. Without any tweak, the standard optimization goal is to plan as many transports as possible with as few vehicles as possible.   * &#x60;AVOID_INTERSECTIONS&#x60; - The focus of this approach is to avoid intersections of edges, where an edge is a straight line drawn between two consecutive stops in a route. The number of routes may be higher compared to the standard optimization goal.   * &#x60;IGNORE_MINIMIZATION_OF_NUMBER_OF_ROUTES&#x60; - With this tweak, the number of vehicles used in a plan, and thus the number of routes, is not minimized. (optional)</param>
        /// <param name="considerTransportPriorities">Set transport priority consideration to true or false.  See [here](./concepts/transport-priorities) for more information. (optional, default to false)</param>
        /// <param name="optimizationPremium">Set Optimization Premium to true to boost quality of results for all **quality** modes by taking advantage of additional computational resources.  Transactions&#39; packages for Optimization Premium are calculated differently.  See [here](./concepts/optimization-premium) for more information. (optional, default to false)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> StartOptimizationWithHttpInfo(Guid id, OptimizationQuality? quality = default(OptimizationQuality?), List<TweakToObjective> tweaksToObjective = default(List<TweakToObjective>), bool? considerTransportPriorities = default(bool?), bool? optimizationPremium = default(bool?));
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IOperationsApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Cancels the current operation of a plan. After cancelling an operation, the operation status for this plan can no longer be retrieved.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routeoptimization.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the plan which corresponding operation should be cancelled.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task CancelOperationAsync(Guid id, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Cancels the current operation of a plan. After cancelling an operation, the operation status for this plan can no longer be retrieved.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routeoptimization.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the plan which corresponding operation should be cancelled.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> CancelOperationWithHttpInfoAsync(Guid id, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Retrieves the status of the current operation that is executed for the plan. If currently no operation is executed the status of the last executed operation is returned.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routeoptimization.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the plan for which the corresponding operation status should be requested.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Operation</returns>
        System.Threading.Tasks.Task<Operation> GetOperationStatusAsync(Guid id, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Retrieves the status of the current operation that is executed for the plan. If currently no operation is executed the status of the last executed operation is returned.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routeoptimization.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the plan for which the corresponding operation status should be requested.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Operation)</returns>
        System.Threading.Tasks.Task<ApiResponse<Operation>> GetOperationStatusWithHttpInfoAsync(Guid id, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Starts an asynchronous evaluation of the specified plan. Only one operation can be started for a plan at a time. Trying to start another operation before the current operation is finished results in an error. Whether an operation is finished or not can be checked with \&quot;getOperationStatus\&quot;. To get the result after the operation is finished \&quot;getPlan\&quot; can be used. Evaluation of a plan calculates driving times, service times, break and rest times and waiting times taking into account given time intervals. It may happen that not all restrictions can be fullfilled in which case one or more violations are reported. Evaluation does not change which transports are scheduled into which route nor their sequence, it does also not change the assignments of routes to vehicles.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routeoptimization.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the plan to be evaluated.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task StartEvaluationAsync(Guid id, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Starts an asynchronous evaluation of the specified plan. Only one operation can be started for a plan at a time. Trying to start another operation before the current operation is finished results in an error. Whether an operation is finished or not can be checked with \&quot;getOperationStatus\&quot;. To get the result after the operation is finished \&quot;getPlan\&quot; can be used. Evaluation of a plan calculates driving times, service times, break and rest times and waiting times taking into account given time intervals. It may happen that not all restrictions can be fullfilled in which case one or more violations are reported. Evaluation does not change which transports are scheduled into which route nor their sequence, it does also not change the assignments of routes to vehicles.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routeoptimization.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the plan to be evaluated.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> StartEvaluationWithHttpInfoAsync(Guid id, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Starts an asynchronous optimization of the specified plan. Only one operation can be started for a plan at a time. Trying to start another operation before the current operation is finished results in an error. Whether an operation is finished or not can be checked with \&quot;getOperationStatus\&quot;. To get the result after the operation is finished \&quot;getPlan\&quot; can be used. In the optimized plan, routes ideally include all transports that are specified in the request. Routes have additional information like arrival and departure times, driving times, service times and more.  If you call startOptimization multiple times consecutively for the same id, the optimization uses the result of the previous optimization as input, so previously planned transports remain planned in the output routes. If this is not what you intend to do, you can create a new plan before another startOptimization call.  When starting the optimization, the number of transports in the plan is used to calculate the number of transactions, see [here](../../help/faq-help) for more information.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routeoptimization.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the plan to be optimized.</param>
        /// <param name="quality">The optimization quality defines the tradeoff between calculation time and quality. A high solution quality and a low calculation time are conflicting. A larger solution search space may lead to a better solution but will take more calculation time.   * &#x60;STANDARD&#x60; - This quality level represents a good trade-off between solution quality and calculation time.   * &#x60;HIGH&#x60; - On this quality level, the search space is larger than on the standard level. This may lead to a better solution but will take more calculation time. (optional)</param>
        /// <param name="tweaksToObjective">A tweak to objective defines additional optimization criteria. Without any tweak, the standard optimization goal is to plan as many transports as possible with as few vehicles as possible.   * &#x60;AVOID_INTERSECTIONS&#x60; - The focus of this approach is to avoid intersections of edges, where an edge is a straight line drawn between two consecutive stops in a route. The number of routes may be higher compared to the standard optimization goal.   * &#x60;IGNORE_MINIMIZATION_OF_NUMBER_OF_ROUTES&#x60; - With this tweak, the number of vehicles used in a plan, and thus the number of routes, is not minimized. (optional)</param>
        /// <param name="considerTransportPriorities">Set transport priority consideration to true or false.  See [here](./concepts/transport-priorities) for more information. (optional, default to false)</param>
        /// <param name="optimizationPremium">Set Optimization Premium to true to boost quality of results for all **quality** modes by taking advantage of additional computational resources.  Transactions&#39; packages for Optimization Premium are calculated differently.  See [here](./concepts/optimization-premium) for more information. (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task StartOptimizationAsync(Guid id, OptimizationQuality? quality = default(OptimizationQuality?), List<TweakToObjective> tweaksToObjective = default(List<TweakToObjective>), bool? considerTransportPriorities = default(bool?), bool? optimizationPremium = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Starts an asynchronous optimization of the specified plan. Only one operation can be started for a plan at a time. Trying to start another operation before the current operation is finished results in an error. Whether an operation is finished or not can be checked with \&quot;getOperationStatus\&quot;. To get the result after the operation is finished \&quot;getPlan\&quot; can be used. In the optimized plan, routes ideally include all transports that are specified in the request. Routes have additional information like arrival and departure times, driving times, service times and more.  If you call startOptimization multiple times consecutively for the same id, the optimization uses the result of the previous optimization as input, so previously planned transports remain planned in the output routes. If this is not what you intend to do, you can create a new plan before another startOptimization call.  When starting the optimization, the number of transports in the plan is used to calculate the number of transactions, see [here](../../help/faq-help) for more information.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routeoptimization.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the plan to be optimized.</param>
        /// <param name="quality">The optimization quality defines the tradeoff between calculation time and quality. A high solution quality and a low calculation time are conflicting. A larger solution search space may lead to a better solution but will take more calculation time.   * &#x60;STANDARD&#x60; - This quality level represents a good trade-off between solution quality and calculation time.   * &#x60;HIGH&#x60; - On this quality level, the search space is larger than on the standard level. This may lead to a better solution but will take more calculation time. (optional)</param>
        /// <param name="tweaksToObjective">A tweak to objective defines additional optimization criteria. Without any tweak, the standard optimization goal is to plan as many transports as possible with as few vehicles as possible.   * &#x60;AVOID_INTERSECTIONS&#x60; - The focus of this approach is to avoid intersections of edges, where an edge is a straight line drawn between two consecutive stops in a route. The number of routes may be higher compared to the standard optimization goal.   * &#x60;IGNORE_MINIMIZATION_OF_NUMBER_OF_ROUTES&#x60; - With this tweak, the number of vehicles used in a plan, and thus the number of routes, is not minimized. (optional)</param>
        /// <param name="considerTransportPriorities">Set transport priority consideration to true or false.  See [here](./concepts/transport-priorities) for more information. (optional, default to false)</param>
        /// <param name="optimizationPremium">Set Optimization Premium to true to boost quality of results for all **quality** modes by taking advantage of additional computational resources.  Transactions&#39; packages for Optimization Premium are calculated differently.  See [here](./concepts/optimization-premium) for more information. (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> StartOptimizationWithHttpInfoAsync(Guid id, OptimizationQuality? quality = default(OptimizationQuality?), List<TweakToObjective> tweaksToObjective = default(List<TweakToObjective>), bool? considerTransportPriorities = default(bool?), bool? optimizationPremium = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IOperationsApi : IOperationsApiSync, IOperationsApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class OperationsApi : IOperationsApi
    {
        private PTV.Developer.Clients.routeoptimization.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="OperationsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public OperationsApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="OperationsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public OperationsApi(string basePath)
        {
            this.Configuration = PTV.Developer.Clients.routeoptimization.Client.Configuration.MergeConfigurations(
                PTV.Developer.Clients.routeoptimization.Client.GlobalConfiguration.Instance,
                new PTV.Developer.Clients.routeoptimization.Client.Configuration { BasePath = basePath }
            );
            this.Client = new PTV.Developer.Clients.routeoptimization.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new PTV.Developer.Clients.routeoptimization.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = PTV.Developer.Clients.routeoptimization.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="OperationsApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public OperationsApi(PTV.Developer.Clients.routeoptimization.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = PTV.Developer.Clients.routeoptimization.Client.Configuration.MergeConfigurations(
                PTV.Developer.Clients.routeoptimization.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new PTV.Developer.Clients.routeoptimization.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new PTV.Developer.Clients.routeoptimization.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = PTV.Developer.Clients.routeoptimization.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="OperationsApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public OperationsApi(PTV.Developer.Clients.routeoptimization.Client.ISynchronousClient client, PTV.Developer.Clients.routeoptimization.Client.IAsynchronousClient asyncClient, PTV.Developer.Clients.routeoptimization.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = PTV.Developer.Clients.routeoptimization.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public PTV.Developer.Clients.routeoptimization.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public PTV.Developer.Clients.routeoptimization.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public PTV.Developer.Clients.routeoptimization.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public PTV.Developer.Clients.routeoptimization.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        ///  Cancels the current operation of a plan. After cancelling an operation, the operation status for this plan can no longer be retrieved.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routeoptimization.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the plan which corresponding operation should be cancelled.</param>
        /// <returns></returns>
        public void CancelOperation(Guid id)
        {
            CancelOperationWithHttpInfo(id);
        }

        /// <summary>
        ///  Cancels the current operation of a plan. After cancelling an operation, the operation status for this plan can no longer be retrieved.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routeoptimization.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the plan which corresponding operation should be cancelled.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public PTV.Developer.Clients.routeoptimization.Client.ApiResponse<Object> CancelOperationWithHttpInfo(Guid id)
        {
            PTV.Developer.Clients.routeoptimization.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.routeoptimization.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.routeoptimization.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.routeoptimization.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", PTV.Developer.Clients.routeoptimization.Client.ClientUtils.ParameterToString(id)); // path parameter

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/plans/{id}/operation", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CancelOperation", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Cancels the current operation of a plan. After cancelling an operation, the operation status for this plan can no longer be retrieved.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routeoptimization.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the plan which corresponding operation should be cancelled.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task CancelOperationAsync(Guid id, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await CancelOperationWithHttpInfoAsync(id, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        ///  Cancels the current operation of a plan. After cancelling an operation, the operation status for this plan can no longer be retrieved.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routeoptimization.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the plan which corresponding operation should be cancelled.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<PTV.Developer.Clients.routeoptimization.Client.ApiResponse<Object>> CancelOperationWithHttpInfoAsync(Guid id, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            PTV.Developer.Clients.routeoptimization.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.routeoptimization.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.routeoptimization.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.routeoptimization.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", PTV.Developer.Clients.routeoptimization.Client.ClientUtils.ParameterToString(id)); // path parameter

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/plans/{id}/operation", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CancelOperation", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Retrieves the status of the current operation that is executed for the plan. If currently no operation is executed the status of the last executed operation is returned.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routeoptimization.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the plan for which the corresponding operation status should be requested.</param>
        /// <returns>Operation</returns>
        public Operation GetOperationStatus(Guid id)
        {
            PTV.Developer.Clients.routeoptimization.Client.ApiResponse<Operation> localVarResponse = GetOperationStatusWithHttpInfo(id);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Retrieves the status of the current operation that is executed for the plan. If currently no operation is executed the status of the last executed operation is returned.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routeoptimization.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the plan for which the corresponding operation status should be requested.</param>
        /// <returns>ApiResponse of Operation</returns>
        public PTV.Developer.Clients.routeoptimization.Client.ApiResponse<Operation> GetOperationStatusWithHttpInfo(Guid id)
        {
            PTV.Developer.Clients.routeoptimization.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.routeoptimization.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.routeoptimization.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.routeoptimization.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", PTV.Developer.Clients.routeoptimization.Client.ClientUtils.ParameterToString(id)); // path parameter

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Operation>("/plans/{id}/operation", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetOperationStatus", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Retrieves the status of the current operation that is executed for the plan. If currently no operation is executed the status of the last executed operation is returned.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routeoptimization.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the plan for which the corresponding operation status should be requested.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Operation</returns>
        public async System.Threading.Tasks.Task<Operation> GetOperationStatusAsync(Guid id, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            PTV.Developer.Clients.routeoptimization.Client.ApiResponse<Operation> localVarResponse = await GetOperationStatusWithHttpInfoAsync(id, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Retrieves the status of the current operation that is executed for the plan. If currently no operation is executed the status of the last executed operation is returned.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routeoptimization.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the plan for which the corresponding operation status should be requested.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Operation)</returns>
        public async System.Threading.Tasks.Task<PTV.Developer.Clients.routeoptimization.Client.ApiResponse<Operation>> GetOperationStatusWithHttpInfoAsync(Guid id, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            PTV.Developer.Clients.routeoptimization.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.routeoptimization.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.routeoptimization.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.routeoptimization.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", PTV.Developer.Clients.routeoptimization.Client.ClientUtils.ParameterToString(id)); // path parameter

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<Operation>("/plans/{id}/operation", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetOperationStatus", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Starts an asynchronous evaluation of the specified plan. Only one operation can be started for a plan at a time. Trying to start another operation before the current operation is finished results in an error. Whether an operation is finished or not can be checked with \&quot;getOperationStatus\&quot;. To get the result after the operation is finished \&quot;getPlan\&quot; can be used. Evaluation of a plan calculates driving times, service times, break and rest times and waiting times taking into account given time intervals. It may happen that not all restrictions can be fullfilled in which case one or more violations are reported. Evaluation does not change which transports are scheduled into which route nor their sequence, it does also not change the assignments of routes to vehicles.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routeoptimization.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the plan to be evaluated.</param>
        /// <returns></returns>
        public void StartEvaluation(Guid id)
        {
            StartEvaluationWithHttpInfo(id);
        }

        /// <summary>
        ///  Starts an asynchronous evaluation of the specified plan. Only one operation can be started for a plan at a time. Trying to start another operation before the current operation is finished results in an error. Whether an operation is finished or not can be checked with \&quot;getOperationStatus\&quot;. To get the result after the operation is finished \&quot;getPlan\&quot; can be used. Evaluation of a plan calculates driving times, service times, break and rest times and waiting times taking into account given time intervals. It may happen that not all restrictions can be fullfilled in which case one or more violations are reported. Evaluation does not change which transports are scheduled into which route nor their sequence, it does also not change the assignments of routes to vehicles.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routeoptimization.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the plan to be evaluated.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public PTV.Developer.Clients.routeoptimization.Client.ApiResponse<Object> StartEvaluationWithHttpInfo(Guid id)
        {
            PTV.Developer.Clients.routeoptimization.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.routeoptimization.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.routeoptimization.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.routeoptimization.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", PTV.Developer.Clients.routeoptimization.Client.ClientUtils.ParameterToString(id)); // path parameter

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/plans/{id}/operation/evaluation", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("StartEvaluation", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Starts an asynchronous evaluation of the specified plan. Only one operation can be started for a plan at a time. Trying to start another operation before the current operation is finished results in an error. Whether an operation is finished or not can be checked with \&quot;getOperationStatus\&quot;. To get the result after the operation is finished \&quot;getPlan\&quot; can be used. Evaluation of a plan calculates driving times, service times, break and rest times and waiting times taking into account given time intervals. It may happen that not all restrictions can be fullfilled in which case one or more violations are reported. Evaluation does not change which transports are scheduled into which route nor their sequence, it does also not change the assignments of routes to vehicles.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routeoptimization.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the plan to be evaluated.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task StartEvaluationAsync(Guid id, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await StartEvaluationWithHttpInfoAsync(id, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        ///  Starts an asynchronous evaluation of the specified plan. Only one operation can be started for a plan at a time. Trying to start another operation before the current operation is finished results in an error. Whether an operation is finished or not can be checked with \&quot;getOperationStatus\&quot;. To get the result after the operation is finished \&quot;getPlan\&quot; can be used. Evaluation of a plan calculates driving times, service times, break and rest times and waiting times taking into account given time intervals. It may happen that not all restrictions can be fullfilled in which case one or more violations are reported. Evaluation does not change which transports are scheduled into which route nor their sequence, it does also not change the assignments of routes to vehicles.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routeoptimization.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the plan to be evaluated.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<PTV.Developer.Clients.routeoptimization.Client.ApiResponse<Object>> StartEvaluationWithHttpInfoAsync(Guid id, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            PTV.Developer.Clients.routeoptimization.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.routeoptimization.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.routeoptimization.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.routeoptimization.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", PTV.Developer.Clients.routeoptimization.Client.ClientUtils.ParameterToString(id)); // path parameter

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/plans/{id}/operation/evaluation", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("StartEvaluation", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Starts an asynchronous optimization of the specified plan. Only one operation can be started for a plan at a time. Trying to start another operation before the current operation is finished results in an error. Whether an operation is finished or not can be checked with \&quot;getOperationStatus\&quot;. To get the result after the operation is finished \&quot;getPlan\&quot; can be used. In the optimized plan, routes ideally include all transports that are specified in the request. Routes have additional information like arrival and departure times, driving times, service times and more.  If you call startOptimization multiple times consecutively for the same id, the optimization uses the result of the previous optimization as input, so previously planned transports remain planned in the output routes. If this is not what you intend to do, you can create a new plan before another startOptimization call.  When starting the optimization, the number of transports in the plan is used to calculate the number of transactions, see [here](../../help/faq-help) for more information.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routeoptimization.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the plan to be optimized.</param>
        /// <param name="quality">The optimization quality defines the tradeoff between calculation time and quality. A high solution quality and a low calculation time are conflicting. A larger solution search space may lead to a better solution but will take more calculation time.   * &#x60;STANDARD&#x60; - This quality level represents a good trade-off between solution quality and calculation time.   * &#x60;HIGH&#x60; - On this quality level, the search space is larger than on the standard level. This may lead to a better solution but will take more calculation time. (optional)</param>
        /// <param name="tweaksToObjective">A tweak to objective defines additional optimization criteria. Without any tweak, the standard optimization goal is to plan as many transports as possible with as few vehicles as possible.   * &#x60;AVOID_INTERSECTIONS&#x60; - The focus of this approach is to avoid intersections of edges, where an edge is a straight line drawn between two consecutive stops in a route. The number of routes may be higher compared to the standard optimization goal.   * &#x60;IGNORE_MINIMIZATION_OF_NUMBER_OF_ROUTES&#x60; - With this tweak, the number of vehicles used in a plan, and thus the number of routes, is not minimized. (optional)</param>
        /// <param name="considerTransportPriorities">Set transport priority consideration to true or false.  See [here](./concepts/transport-priorities) for more information. (optional, default to false)</param>
        /// <param name="optimizationPremium">Set Optimization Premium to true to boost quality of results for all **quality** modes by taking advantage of additional computational resources.  Transactions&#39; packages for Optimization Premium are calculated differently.  See [here](./concepts/optimization-premium) for more information. (optional, default to false)</param>
        /// <returns></returns>
        public void StartOptimization(Guid id, OptimizationQuality? quality = default(OptimizationQuality?), List<TweakToObjective> tweaksToObjective = default(List<TweakToObjective>), bool? considerTransportPriorities = default(bool?), bool? optimizationPremium = default(bool?))
        {
            StartOptimizationWithHttpInfo(id, quality, tweaksToObjective, considerTransportPriorities, optimizationPremium);
        }

        /// <summary>
        ///  Starts an asynchronous optimization of the specified plan. Only one operation can be started for a plan at a time. Trying to start another operation before the current operation is finished results in an error. Whether an operation is finished or not can be checked with \&quot;getOperationStatus\&quot;. To get the result after the operation is finished \&quot;getPlan\&quot; can be used. In the optimized plan, routes ideally include all transports that are specified in the request. Routes have additional information like arrival and departure times, driving times, service times and more.  If you call startOptimization multiple times consecutively for the same id, the optimization uses the result of the previous optimization as input, so previously planned transports remain planned in the output routes. If this is not what you intend to do, you can create a new plan before another startOptimization call.  When starting the optimization, the number of transports in the plan is used to calculate the number of transactions, see [here](../../help/faq-help) for more information.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routeoptimization.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the plan to be optimized.</param>
        /// <param name="quality">The optimization quality defines the tradeoff between calculation time and quality. A high solution quality and a low calculation time are conflicting. A larger solution search space may lead to a better solution but will take more calculation time.   * &#x60;STANDARD&#x60; - This quality level represents a good trade-off between solution quality and calculation time.   * &#x60;HIGH&#x60; - On this quality level, the search space is larger than on the standard level. This may lead to a better solution but will take more calculation time. (optional)</param>
        /// <param name="tweaksToObjective">A tweak to objective defines additional optimization criteria. Without any tweak, the standard optimization goal is to plan as many transports as possible with as few vehicles as possible.   * &#x60;AVOID_INTERSECTIONS&#x60; - The focus of this approach is to avoid intersections of edges, where an edge is a straight line drawn between two consecutive stops in a route. The number of routes may be higher compared to the standard optimization goal.   * &#x60;IGNORE_MINIMIZATION_OF_NUMBER_OF_ROUTES&#x60; - With this tweak, the number of vehicles used in a plan, and thus the number of routes, is not minimized. (optional)</param>
        /// <param name="considerTransportPriorities">Set transport priority consideration to true or false.  See [here](./concepts/transport-priorities) for more information. (optional, default to false)</param>
        /// <param name="optimizationPremium">Set Optimization Premium to true to boost quality of results for all **quality** modes by taking advantage of additional computational resources.  Transactions&#39; packages for Optimization Premium are calculated differently.  See [here](./concepts/optimization-premium) for more information. (optional, default to false)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public PTV.Developer.Clients.routeoptimization.Client.ApiResponse<Object> StartOptimizationWithHttpInfo(Guid id, OptimizationQuality? quality = default(OptimizationQuality?), List<TweakToObjective> tweaksToObjective = default(List<TweakToObjective>), bool? considerTransportPriorities = default(bool?), bool? optimizationPremium = default(bool?))
        {
            PTV.Developer.Clients.routeoptimization.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.routeoptimization.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.routeoptimization.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.routeoptimization.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", PTV.Developer.Clients.routeoptimization.Client.ClientUtils.ParameterToString(id)); // path parameter
            if (quality != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routeoptimization.Client.ClientUtils.ParameterToMultiMap("", "quality", quality));
            }
            if (tweaksToObjective != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routeoptimization.Client.ClientUtils.ParameterToMultiMap("csv", "tweaksToObjective", tweaksToObjective));
            }
            if (considerTransportPriorities != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routeoptimization.Client.ClientUtils.ParameterToMultiMap("", "considerTransportPriorities", considerTransportPriorities));
            }
            if (optimizationPremium != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routeoptimization.Client.ClientUtils.ParameterToMultiMap("", "optimizationPremium", optimizationPremium));
            }

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/plans/{id}/operation/optimization", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("StartOptimization", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Starts an asynchronous optimization of the specified plan. Only one operation can be started for a plan at a time. Trying to start another operation before the current operation is finished results in an error. Whether an operation is finished or not can be checked with \&quot;getOperationStatus\&quot;. To get the result after the operation is finished \&quot;getPlan\&quot; can be used. In the optimized plan, routes ideally include all transports that are specified in the request. Routes have additional information like arrival and departure times, driving times, service times and more.  If you call startOptimization multiple times consecutively for the same id, the optimization uses the result of the previous optimization as input, so previously planned transports remain planned in the output routes. If this is not what you intend to do, you can create a new plan before another startOptimization call.  When starting the optimization, the number of transports in the plan is used to calculate the number of transactions, see [here](../../help/faq-help) for more information.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routeoptimization.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the plan to be optimized.</param>
        /// <param name="quality">The optimization quality defines the tradeoff between calculation time and quality. A high solution quality and a low calculation time are conflicting. A larger solution search space may lead to a better solution but will take more calculation time.   * &#x60;STANDARD&#x60; - This quality level represents a good trade-off between solution quality and calculation time.   * &#x60;HIGH&#x60; - On this quality level, the search space is larger than on the standard level. This may lead to a better solution but will take more calculation time. (optional)</param>
        /// <param name="tweaksToObjective">A tweak to objective defines additional optimization criteria. Without any tweak, the standard optimization goal is to plan as many transports as possible with as few vehicles as possible.   * &#x60;AVOID_INTERSECTIONS&#x60; - The focus of this approach is to avoid intersections of edges, where an edge is a straight line drawn between two consecutive stops in a route. The number of routes may be higher compared to the standard optimization goal.   * &#x60;IGNORE_MINIMIZATION_OF_NUMBER_OF_ROUTES&#x60; - With this tweak, the number of vehicles used in a plan, and thus the number of routes, is not minimized. (optional)</param>
        /// <param name="considerTransportPriorities">Set transport priority consideration to true or false.  See [here](./concepts/transport-priorities) for more information. (optional, default to false)</param>
        /// <param name="optimizationPremium">Set Optimization Premium to true to boost quality of results for all **quality** modes by taking advantage of additional computational resources.  Transactions&#39; packages for Optimization Premium are calculated differently.  See [here](./concepts/optimization-premium) for more information. (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task StartOptimizationAsync(Guid id, OptimizationQuality? quality = default(OptimizationQuality?), List<TweakToObjective> tweaksToObjective = default(List<TweakToObjective>), bool? considerTransportPriorities = default(bool?), bool? optimizationPremium = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await StartOptimizationWithHttpInfoAsync(id, quality, tweaksToObjective, considerTransportPriorities, optimizationPremium, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        ///  Starts an asynchronous optimization of the specified plan. Only one operation can be started for a plan at a time. Trying to start another operation before the current operation is finished results in an error. Whether an operation is finished or not can be checked with \&quot;getOperationStatus\&quot;. To get the result after the operation is finished \&quot;getPlan\&quot; can be used. In the optimized plan, routes ideally include all transports that are specified in the request. Routes have additional information like arrival and departure times, driving times, service times and more.  If you call startOptimization multiple times consecutively for the same id, the optimization uses the result of the previous optimization as input, so previously planned transports remain planned in the output routes. If this is not what you intend to do, you can create a new plan before another startOptimization call.  When starting the optimization, the number of transports in the plan is used to calculate the number of transactions, see [here](../../help/faq-help) for more information.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routeoptimization.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the plan to be optimized.</param>
        /// <param name="quality">The optimization quality defines the tradeoff between calculation time and quality. A high solution quality and a low calculation time are conflicting. A larger solution search space may lead to a better solution but will take more calculation time.   * &#x60;STANDARD&#x60; - This quality level represents a good trade-off between solution quality and calculation time.   * &#x60;HIGH&#x60; - On this quality level, the search space is larger than on the standard level. This may lead to a better solution but will take more calculation time. (optional)</param>
        /// <param name="tweaksToObjective">A tweak to objective defines additional optimization criteria. Without any tweak, the standard optimization goal is to plan as many transports as possible with as few vehicles as possible.   * &#x60;AVOID_INTERSECTIONS&#x60; - The focus of this approach is to avoid intersections of edges, where an edge is a straight line drawn between two consecutive stops in a route. The number of routes may be higher compared to the standard optimization goal.   * &#x60;IGNORE_MINIMIZATION_OF_NUMBER_OF_ROUTES&#x60; - With this tweak, the number of vehicles used in a plan, and thus the number of routes, is not minimized. (optional)</param>
        /// <param name="considerTransportPriorities">Set transport priority consideration to true or false.  See [here](./concepts/transport-priorities) for more information. (optional, default to false)</param>
        /// <param name="optimizationPremium">Set Optimization Premium to true to boost quality of results for all **quality** modes by taking advantage of additional computational resources.  Transactions&#39; packages for Optimization Premium are calculated differently.  See [here](./concepts/optimization-premium) for more information. (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<PTV.Developer.Clients.routeoptimization.Client.ApiResponse<Object>> StartOptimizationWithHttpInfoAsync(Guid id, OptimizationQuality? quality = default(OptimizationQuality?), List<TweakToObjective> tweaksToObjective = default(List<TweakToObjective>), bool? considerTransportPriorities = default(bool?), bool? optimizationPremium = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            PTV.Developer.Clients.routeoptimization.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.routeoptimization.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.routeoptimization.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.routeoptimization.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", PTV.Developer.Clients.routeoptimization.Client.ClientUtils.ParameterToString(id)); // path parameter
            if (quality != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routeoptimization.Client.ClientUtils.ParameterToMultiMap("", "quality", quality));
            }
            if (tweaksToObjective != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routeoptimization.Client.ClientUtils.ParameterToMultiMap("csv", "tweaksToObjective", tweaksToObjective));
            }
            if (considerTransportPriorities != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routeoptimization.Client.ClientUtils.ParameterToMultiMap("", "considerTransportPriorities", considerTransportPriorities));
            }
            if (optimizationPremium != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routeoptimization.Client.ClientUtils.ParameterToMultiMap("", "optimizationPremium", optimizationPremium));
            }

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/plans/{id}/operation/optimization", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("StartOptimization", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

    }
}
