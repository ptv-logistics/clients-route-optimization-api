/*
 * Route Optimization
 *
 * With the Route Optimization service you can schedule and optimize the routes of your fleet.
 *
 * The version of the OpenAPI document: 1.11
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = PTV.Developer.Clients.routeoptimization.Client.OpenAPIDateConverter;

namespace PTV.Developer.Clients.routeoptimization.Model
{
    /// <summary>
    /// The request object for the service method &#39;createPlan&#39; and the result of the service method &#39;getPlan&#39;.
    /// </summary>
    [DataContract(Name = "Plan")]
    public partial class Plan : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Plan" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected Plan() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="Plan" /> class.
        /// </summary>
        /// <param name="description">A description of the plan..</param>
        /// <param name="locations">A list of depot or customer locations that may be referenced by vehicles, transports and stops. A location is either a depot location or a customer location. Depot locations act as trip delimiters. Each location must be referenced by another object. If a request contains a location not referenced by any other object, the request will be rejected. (required).</param>
        /// <param name="vehicles">A list of vehicles that can be used to transport goods. (required).</param>
        /// <param name="drivers">A list of drivers. A driver is always assigned to a specific vehicle. In turn, a vehicle can but does not need to have a driver assigned to it. If a driver is assigned to a vehicle, the driver&#39;s restrictions apply, such as its limited availability. If no drivers are specified, the drivers of all vehicles are always available..</param>
        /// <param name="transports">A list of transports, that is, orders to transport goods from one location to another location. Depending on your subscription, a more restrictive value for maximum number of transport may apply. Check request limits of your subscription. (required).</param>
        /// <param name="planningHorizon">The planning horizon for the plan, described by start and end date and time. All routes have to start and end within this planning horizon. All opening intervals outside of this planning horizon are not considered by the algorithm. If specified, the planning horizon is restricted to a maximum duration of two weeks. If not specified, the planning horizon is infinite. If no other time interval is specified within this plan, the planning horizon is required..</param>
        /// <param name="restrictions">restrictions.</param>
        /// <param name="routes">A list of routes. A route contains a sequence of stops. It specifies where and in which order goods are to be picked up or delivered. Each stop can be assigned to a trip. A route is subdivided into trips. Each route has at least one trip and a trip consists of at least two stops. At the beginning and end of each trip the vehicle does not carry any load. A trip starts at the vehicle start location or at a depot location, and ends at the vehicle end location or at a depot location. If routes are already given in input they are considered during planning. Transports which are already planned in an input route will also remain planned in the output routes. This might lead to violations of the routes.   See [here](./concepts/routes-and-trips) for more information..</param>
        public Plan(string description = default(string), List<Location> locations = default(List<Location>), List<Vehicle> vehicles = default(List<Vehicle>), List<Driver> drivers = default(List<Driver>), List<Transport> transports = default(List<Transport>), TimeInterval planningHorizon = default(TimeInterval), PlanningRestrictions restrictions = default(PlanningRestrictions), List<Route> routes = default(List<Route>))
        {
            // to ensure "locations" is required (not null)
            if (locations == null)
            {
                throw new ArgumentNullException("locations is a required property for Plan and cannot be null");
            }
            this.Locations = locations;
            // to ensure "vehicles" is required (not null)
            if (vehicles == null)
            {
                throw new ArgumentNullException("vehicles is a required property for Plan and cannot be null");
            }
            this.Vehicles = vehicles;
            // to ensure "transports" is required (not null)
            if (transports == null)
            {
                throw new ArgumentNullException("transports is a required property for Plan and cannot be null");
            }
            this.Transports = transports;
            this.Description = description;
            this.Drivers = drivers;
            this.PlanningHorizon = planningHorizon;
            this.Restrictions = restrictions;
            this.Routes = routes;
        }

        /// <summary>
        /// The ID of the plan. It is generated when the plan is created.
        /// </summary>
        /// <value>The ID of the plan. It is generated when the plan is created.</value>
        [DataMember(Name = "id", IsRequired = true, EmitDefaultValue = true)]
        public Guid Id { get; private set; }

        /// <summary>
        /// Returns false as Id should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeId()
        {
            return false;
        }
        /// <summary>
        /// A description of the plan.
        /// </summary>
        /// <value>A description of the plan.</value>
        [DataMember(Name = "description", EmitDefaultValue = false)]
        public string Description { get; set; }

        /// <summary>
        /// A list of depot or customer locations that may be referenced by vehicles, transports and stops. A location is either a depot location or a customer location. Depot locations act as trip delimiters. Each location must be referenced by another object. If a request contains a location not referenced by any other object, the request will be rejected.
        /// </summary>
        /// <value>A list of depot or customer locations that may be referenced by vehicles, transports and stops. A location is either a depot location or a customer location. Depot locations act as trip delimiters. Each location must be referenced by another object. If a request contains a location not referenced by any other object, the request will be rejected.</value>
        [DataMember(Name = "locations", IsRequired = true, EmitDefaultValue = true)]
        public List<Location> Locations { get; set; }

        /// <summary>
        /// A list of vehicles that can be used to transport goods.
        /// </summary>
        /// <value>A list of vehicles that can be used to transport goods.</value>
        [DataMember(Name = "vehicles", IsRequired = true, EmitDefaultValue = true)]
        public List<Vehicle> Vehicles { get; set; }

        /// <summary>
        /// A list of drivers. A driver is always assigned to a specific vehicle. In turn, a vehicle can but does not need to have a driver assigned to it. If a driver is assigned to a vehicle, the driver&#39;s restrictions apply, such as its limited availability. If no drivers are specified, the drivers of all vehicles are always available.
        /// </summary>
        /// <value>A list of drivers. A driver is always assigned to a specific vehicle. In turn, a vehicle can but does not need to have a driver assigned to it. If a driver is assigned to a vehicle, the driver&#39;s restrictions apply, such as its limited availability. If no drivers are specified, the drivers of all vehicles are always available.</value>
        [DataMember(Name = "drivers", EmitDefaultValue = false)]
        public List<Driver> Drivers { get; set; }

        /// <summary>
        /// A list of transports, that is, orders to transport goods from one location to another location. Depending on your subscription, a more restrictive value for maximum number of transport may apply. Check request limits of your subscription.
        /// </summary>
        /// <value>A list of transports, that is, orders to transport goods from one location to another location. Depending on your subscription, a more restrictive value for maximum number of transport may apply. Check request limits of your subscription.</value>
        [DataMember(Name = "transports", IsRequired = true, EmitDefaultValue = true)]
        public List<Transport> Transports { get; set; }

        /// <summary>
        /// The planning horizon for the plan, described by start and end date and time. All routes have to start and end within this planning horizon. All opening intervals outside of this planning horizon are not considered by the algorithm. If specified, the planning horizon is restricted to a maximum duration of two weeks. If not specified, the planning horizon is infinite. If no other time interval is specified within this plan, the planning horizon is required.
        /// </summary>
        /// <value>The planning horizon for the plan, described by start and end date and time. All routes have to start and end within this planning horizon. All opening intervals outside of this planning horizon are not considered by the algorithm. If specified, the planning horizon is restricted to a maximum duration of two weeks. If not specified, the planning horizon is infinite. If no other time interval is specified within this plan, the planning horizon is required.</value>
        [DataMember(Name = "planningHorizon", EmitDefaultValue = false)]
        public TimeInterval PlanningHorizon { get; set; }

        /// <summary>
        /// Gets or Sets Restrictions
        /// </summary>
        [DataMember(Name = "restrictions", EmitDefaultValue = false)]
        public PlanningRestrictions Restrictions { get; set; }

        /// <summary>
        /// A list of routes. A route contains a sequence of stops. It specifies where and in which order goods are to be picked up or delivered. Each stop can be assigned to a trip. A route is subdivided into trips. Each route has at least one trip and a trip consists of at least two stops. At the beginning and end of each trip the vehicle does not carry any load. A trip starts at the vehicle start location or at a depot location, and ends at the vehicle end location or at a depot location. If routes are already given in input they are considered during planning. Transports which are already planned in an input route will also remain planned in the output routes. This might lead to violations of the routes.   See [here](./concepts/routes-and-trips) for more information.
        /// </summary>
        /// <value>A list of routes. A route contains a sequence of stops. It specifies where and in which order goods are to be picked up or delivered. Each stop can be assigned to a trip. A route is subdivided into trips. Each route has at least one trip and a trip consists of at least two stops. At the beginning and end of each trip the vehicle does not carry any load. A trip starts at the vehicle start location or at a depot location, and ends at the vehicle end location or at a depot location. If routes are already given in input they are considered during planning. Transports which are already planned in an input route will also remain planned in the output routes. This might lead to violations of the routes.   See [here](./concepts/routes-and-trips) for more information.</value>
        [DataMember(Name = "routes", EmitDefaultValue = false)]
        public List<Route> Routes { get; set; }

        /// <summary>
        /// Returns the vehicle IDs that are not used in the response of an optimization operation. These vehicles are not assigned to any route.
        /// </summary>
        /// <value>Returns the vehicle IDs that are not used in the response of an optimization operation. These vehicles are not assigned to any route.</value>
        [DataMember(Name = "unplannedVehicleIds", EmitDefaultValue = false)]
        public List<string> UnplannedVehicleIds { get; private set; }

        /// <summary>
        /// Returns false as UnplannedVehicleIds should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeUnplannedVehicleIds()
        {
            return false;
        }
        /// <summary>
        /// Returns the transport IDs that could not be planned in the response of an optimization operation. These transports are not part of the routes.
        /// </summary>
        /// <value>Returns the transport IDs that could not be planned in the response of an optimization operation. These transports are not part of the routes.</value>
        [DataMember(Name = "unplannedTransportIds", EmitDefaultValue = false)]
        public List<string> UnplannedTransportIds { get; private set; }

        /// <summary>
        /// Returns false as UnplannedTransportIds should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeUnplannedTransportIds()
        {
            return false;
        }
        /// <summary>
        /// A list of warnings concerning the validity of the result.
        /// </summary>
        /// <value>A list of warnings concerning the validity of the result.</value>
        [DataMember(Name = "warnings", EmitDefaultValue = false)]
        public List<Warning> Warnings { get; private set; }

        /// <summary>
        /// Returns false as Warnings should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeWarnings()
        {
            return false;
        }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class Plan {\n");
            sb.Append("  Id: ").Append(Id).Append("\n");
            sb.Append("  Description: ").Append(Description).Append("\n");
            sb.Append("  Locations: ").Append(Locations).Append("\n");
            sb.Append("  Vehicles: ").Append(Vehicles).Append("\n");
            sb.Append("  Drivers: ").Append(Drivers).Append("\n");
            sb.Append("  Transports: ").Append(Transports).Append("\n");
            sb.Append("  PlanningHorizon: ").Append(PlanningHorizon).Append("\n");
            sb.Append("  Restrictions: ").Append(Restrictions).Append("\n");
            sb.Append("  Routes: ").Append(Routes).Append("\n");
            sb.Append("  UnplannedVehicleIds: ").Append(UnplannedVehicleIds).Append("\n");
            sb.Append("  UnplannedTransportIds: ").Append(UnplannedTransportIds).Append("\n");
            sb.Append("  Warnings: ").Append(Warnings).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
