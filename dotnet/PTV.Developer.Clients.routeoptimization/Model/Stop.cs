/*
 * Route Optimization
 *
 * With the Route Optimization service you can schedule and optimize the routes of your fleet.
 *
 * The version of the OpenAPI document: 1.7
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = PTV.Developer.Clients.routeoptimization.Client.OpenAPIDateConverter;

namespace PTV.Developer.Clients.routeoptimization.Model
{
    /// <summary>
    /// A stop groups subsequent deliveries and/or pickups at the same location. At a customer location, transports are scheduled in order of their type: deliveries before pickups. At a depot location a stop groups either deliveries or pickups.  See [here](./concepts/locations-transports-and-stops) for more information.
    /// </summary>
    [DataContract(Name = "Stop")]
    public partial class Stop : IEquatable<Stop>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Stop" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected Stop() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="Stop" /> class.
        /// </summary>
        /// <param name="locationId">A reference to a location. Usually, goods are picked up or delivered here. If no goods are picked up or delivered, it is the location where a route or a trip starts or ends. (required).</param>
        /// <param name="tripId">The trip ID groups several subsequent stops. The first stop and the last stop of a route may not have a trip ID only if the vehicle that is assigned to this route has a start or an end location, respectively.  See [here](./concepts/routes-and-trips) for more information..</param>
        /// <param name="deliveryIds">A list of transport IDs that are delivered at this stop..</param>
        /// <param name="pickupIds">A list of transport IDs that are picked up at this stop..</param>
        public Stop(string locationId = default(string), string tripId = default(string), List<string> deliveryIds = default(List<string>), List<string> pickupIds = default(List<string>))
        {
            // to ensure "locationId" is required (not null)
            if (locationId == null) {
                throw new ArgumentNullException("locationId is a required property for Stop and cannot be null");
            }
            this.LocationId = locationId;
            this.TripId = tripId;
            this.DeliveryIds = deliveryIds;
            this.PickupIds = pickupIds;
        }

        /// <summary>
        /// A reference to a location. Usually, goods are picked up or delivered here. If no goods are picked up or delivered, it is the location where a route or a trip starts or ends.
        /// </summary>
        /// <value>A reference to a location. Usually, goods are picked up or delivered here. If no goods are picked up or delivered, it is the location where a route or a trip starts or ends.</value>
        [DataMember(Name = "locationId", IsRequired = true, EmitDefaultValue = false)]
        public string LocationId { get; set; }

        /// <summary>
        /// The trip ID groups several subsequent stops. The first stop and the last stop of a route may not have a trip ID only if the vehicle that is assigned to this route has a start or an end location, respectively.  See [here](./concepts/routes-and-trips) for more information.
        /// </summary>
        /// <value>The trip ID groups several subsequent stops. The first stop and the last stop of a route may not have a trip ID only if the vehicle that is assigned to this route has a start or an end location, respectively.  See [here](./concepts/routes-and-trips) for more information.</value>
        [DataMember(Name = "tripId", EmitDefaultValue = false)]
        public string TripId { get; set; }

        /// <summary>
        /// A list of transport IDs that are delivered at this stop.
        /// </summary>
        /// <value>A list of transport IDs that are delivered at this stop.</value>
        [DataMember(Name = "deliveryIds", EmitDefaultValue = false)]
        public List<string> DeliveryIds { get; set; }

        /// <summary>
        /// A list of transport IDs that are picked up at this stop.
        /// </summary>
        /// <value>A list of transport IDs that are picked up at this stop.</value>
        [DataMember(Name = "pickupIds", EmitDefaultValue = false)]
        public List<string> PickupIds { get; set; }

        /// <summary>
        /// Contains summary values of the events on the way from the previous stop to the current stop, including the driving time. The very first stop of a route has a way report with empty values.
        /// </summary>
        /// <value>Contains summary values of the events on the way from the previous stop to the current stop, including the driving time. The very first stop of a route has a way report with empty values.</value>
        [DataMember(Name = "reportForWayToStop", IsRequired = true, EmitDefaultValue = true)]
        public WayReport ReportForWayToStop { get; private set; }

        /// <summary>
        /// Returns false as ReportForWayToStop should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeReportForWayToStop()
        {
            return false;
        }
        /// <summary>
        /// Contains summary values of the events at a stop, including the arrival time, the departure time and the service time It also contains information about the loaded quantities when leaving the current stop.
        /// </summary>
        /// <value>Contains summary values of the events at a stop, including the arrival time, the departure time and the service time It also contains information about the loaded quantities when leaving the current stop.</value>
        [DataMember(Name = "reportForStop", IsRequired = true, EmitDefaultValue = true)]
        public StopReport ReportForStop { get; private set; }

        /// <summary>
        /// Returns false as ReportForStop should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeReportForStop()
        {
            return false;
        }
        /// <summary>
        /// A list of events that occur on the way from the previous stop to this stop. An event specifies what happens on a route at a certain point in time. It can describe the driver&#39;s activity such as driving or break.
        /// </summary>
        /// <value>A list of events that occur on the way from the previous stop to this stop. An event specifies what happens on a route at a certain point in time. It can describe the driver&#39;s activity such as driving or break.</value>
        [DataMember(Name = "eventsOnWayToStop", IsRequired = true, EmitDefaultValue = false)]
        public List<Event> EventsOnWayToStop { get; private set; }

        /// <summary>
        /// Returns false as EventsOnWayToStop should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeEventsOnWayToStop()
        {
            return false;
        }
        /// <summary>
        /// A list of events that occur at this stop. An event specifies what happens on a route at a certain point in time. It can describe the driver&#39;s activity such as performing service or waiting, or it can denote the start/end of a route/trip.
        /// </summary>
        /// <value>A list of events that occur at this stop. An event specifies what happens on a route at a certain point in time. It can describe the driver&#39;s activity such as performing service or waiting, or it can denote the start/end of a route/trip.</value>
        [DataMember(Name = "eventsAtStop", IsRequired = true, EmitDefaultValue = false)]
        public List<Event> EventsAtStop { get; private set; }

        /// <summary>
        /// Returns false as EventsAtStop should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeEventsAtStop()
        {
            return false;
        }
        /// <summary>
        /// A list of violations that occur on the way from the previous stop to this stop. The following violation types can occur here: _PLANNING_HORIZON_, _DRIVER_AVAILABILITY_, _MAXIMUM_TRAVEL_TIME_OF_DRIVER_, _MAXIMUM_DRIVING_TIME_OF_DRIVER_, _REST_POSITION_.    _REST_POSITION_ is reported if a daily rest has to be taken on the way to this stop to respect the daily rest rule. The expected position for a daily rest is at the end of a trip. For all other violations, the maximum time exceedance on the way to this stop is reported.    Violations of type _PLANNING_HORIZON_ and _MAXIMUM_TRAVEL_TIME_OF_DRIVER_ will reoccur (with increasing value for TimeExceedence) for all following ways and stops of the current route.    Violations of type _MAXIMUM_DRIVING_TIME_OF_DRIVER_ will reoccur (with increasing value for TimeExceedence) for all following ways of the current route.    Violations of type _DRIVER_AVAILABILITY_ will reoccur (with increasing value for TimeExceedence) for all following ways and stops of the current trip.
        /// </summary>
        /// <value>A list of violations that occur on the way from the previous stop to this stop. The following violation types can occur here: _PLANNING_HORIZON_, _DRIVER_AVAILABILITY_, _MAXIMUM_TRAVEL_TIME_OF_DRIVER_, _MAXIMUM_DRIVING_TIME_OF_DRIVER_, _REST_POSITION_.    _REST_POSITION_ is reported if a daily rest has to be taken on the way to this stop to respect the daily rest rule. The expected position for a daily rest is at the end of a trip. For all other violations, the maximum time exceedance on the way to this stop is reported.    Violations of type _PLANNING_HORIZON_ and _MAXIMUM_TRAVEL_TIME_OF_DRIVER_ will reoccur (with increasing value for TimeExceedence) for all following ways and stops of the current route.    Violations of type _MAXIMUM_DRIVING_TIME_OF_DRIVER_ will reoccur (with increasing value for TimeExceedence) for all following ways of the current route.    Violations of type _DRIVER_AVAILABILITY_ will reoccur (with increasing value for TimeExceedence) for all following ways and stops of the current trip.</value>
        [DataMember(Name = "violationsOnWayToStop", IsRequired = true, EmitDefaultValue = false)]
        public List<Violation> ViolationsOnWayToStop { get; private set; }

        /// <summary>
        /// Returns false as ViolationsOnWayToStop should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeViolationsOnWayToStop()
        {
            return false;
        }
        /// <summary>
        /// A list of violations that occur at this stop. The following violation types can occur here: _PLANNING_HORIZON_, _DRIVER_AVAILABILITY_, _OPENING_INTERVAL_, _VEHICLE_CAPACITY_, _VEHICLE_EQUIPMENT_, _MAXIMUM_TRAVEL_TIME_PER_DRIVER_, _REST_POSITION_, _STOP_POSITION_IN_TRIP_, _TRIP_SECTION_, _MIXED_LOADING_PROHIBITION_.    For _VEHICLE_CAPACITY_ and _VEHICLE_EQUIPMENT_, the violation when leaving the stop is reported (i.e., at the last stop of the route, when everything is unloaded, there will be no such violation).    _REST_POSITION_ is reported if a daily rest has to be taken at this stop to respect the daily rest rule. The expected position for a daily rest is at the end of a trip. For all other violations, the maximum time exceedance at this stop is reported.    Violations of type _PLANNING_HORIZON_ and _MAXIMUM_TRAVEL_TIME_PER_DRIVER_ will reoccur (with increasing value for TimeExceedence) for all following ways and stops of the current route.    Violations of type _DRIVER_AVAILABILITY_ will reoccur (with increasing value for TimeExceedence) for all following ways and stops of the current trip.    Violations of type _VEHICLE_CAPACITY_ will reoccur at all following stops until enough goods are unloaded and the vehicle capacity is not exceeded anymore.    Violations of type _VEHICLE_EQUIPMENT_ will reoccur at all following stops until goods which require the missing equipment are unloaded and no equipment is missing anymore.    Violations of type _STOP_POSITION_IN_TRIP_ will occur at all stops where a position in trip is set for this location ant the current customer stop is not the first/last in the trip.    Violations of type _TRIP_SECTION_ will occur at all stops where the previous trip section number is higher than the one at this customer location.    Violations of type _MIXED_LOADING_PROHIBITION_ will occur at all stops where a load whose category must not be loaded with another load category in the trip is picked up.
        /// </summary>
        /// <value>A list of violations that occur at this stop. The following violation types can occur here: _PLANNING_HORIZON_, _DRIVER_AVAILABILITY_, _OPENING_INTERVAL_, _VEHICLE_CAPACITY_, _VEHICLE_EQUIPMENT_, _MAXIMUM_TRAVEL_TIME_PER_DRIVER_, _REST_POSITION_, _STOP_POSITION_IN_TRIP_, _TRIP_SECTION_, _MIXED_LOADING_PROHIBITION_.    For _VEHICLE_CAPACITY_ and _VEHICLE_EQUIPMENT_, the violation when leaving the stop is reported (i.e., at the last stop of the route, when everything is unloaded, there will be no such violation).    _REST_POSITION_ is reported if a daily rest has to be taken at this stop to respect the daily rest rule. The expected position for a daily rest is at the end of a trip. For all other violations, the maximum time exceedance at this stop is reported.    Violations of type _PLANNING_HORIZON_ and _MAXIMUM_TRAVEL_TIME_PER_DRIVER_ will reoccur (with increasing value for TimeExceedence) for all following ways and stops of the current route.    Violations of type _DRIVER_AVAILABILITY_ will reoccur (with increasing value for TimeExceedence) for all following ways and stops of the current trip.    Violations of type _VEHICLE_CAPACITY_ will reoccur at all following stops until enough goods are unloaded and the vehicle capacity is not exceeded anymore.    Violations of type _VEHICLE_EQUIPMENT_ will reoccur at all following stops until goods which require the missing equipment are unloaded and no equipment is missing anymore.    Violations of type _STOP_POSITION_IN_TRIP_ will occur at all stops where a position in trip is set for this location ant the current customer stop is not the first/last in the trip.    Violations of type _TRIP_SECTION_ will occur at all stops where the previous trip section number is higher than the one at this customer location.    Violations of type _MIXED_LOADING_PROHIBITION_ will occur at all stops where a load whose category must not be loaded with another load category in the trip is picked up.</value>
        [DataMember(Name = "violationsAtStop", IsRequired = true, EmitDefaultValue = false)]
        public List<Violation> ViolationsAtStop { get; private set; }

        /// <summary>
        /// Returns false as ViolationsAtStop should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeViolationsAtStop()
        {
            return false;
        }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class Stop {\n");
            sb.Append("  LocationId: ").Append(LocationId).Append("\n");
            sb.Append("  TripId: ").Append(TripId).Append("\n");
            sb.Append("  DeliveryIds: ").Append(DeliveryIds).Append("\n");
            sb.Append("  PickupIds: ").Append(PickupIds).Append("\n");
            sb.Append("  ReportForWayToStop: ").Append(ReportForWayToStop).Append("\n");
            sb.Append("  ReportForStop: ").Append(ReportForStop).Append("\n");
            sb.Append("  EventsOnWayToStop: ").Append(EventsOnWayToStop).Append("\n");
            sb.Append("  EventsAtStop: ").Append(EventsAtStop).Append("\n");
            sb.Append("  ViolationsOnWayToStop: ").Append(ViolationsOnWayToStop).Append("\n");
            sb.Append("  ViolationsAtStop: ").Append(ViolationsAtStop).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as Stop);
        }

        /// <summary>
        /// Returns true if Stop instances are equal
        /// </summary>
        /// <param name="input">Instance of Stop to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(Stop input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.LocationId == input.LocationId ||
                    (this.LocationId != null &&
                    this.LocationId.Equals(input.LocationId))
                ) && 
                (
                    this.TripId == input.TripId ||
                    (this.TripId != null &&
                    this.TripId.Equals(input.TripId))
                ) && 
                (
                    this.DeliveryIds == input.DeliveryIds ||
                    this.DeliveryIds != null &&
                    input.DeliveryIds != null &&
                    this.DeliveryIds.SequenceEqual(input.DeliveryIds)
                ) && 
                (
                    this.PickupIds == input.PickupIds ||
                    this.PickupIds != null &&
                    input.PickupIds != null &&
                    this.PickupIds.SequenceEqual(input.PickupIds)
                ) && 
                (
                    this.ReportForWayToStop == input.ReportForWayToStop ||
                    (this.ReportForWayToStop != null &&
                    this.ReportForWayToStop.Equals(input.ReportForWayToStop))
                ) && 
                (
                    this.ReportForStop == input.ReportForStop ||
                    (this.ReportForStop != null &&
                    this.ReportForStop.Equals(input.ReportForStop))
                ) && 
                (
                    this.EventsOnWayToStop == input.EventsOnWayToStop ||
                    this.EventsOnWayToStop != null &&
                    input.EventsOnWayToStop != null &&
                    this.EventsOnWayToStop.SequenceEqual(input.EventsOnWayToStop)
                ) && 
                (
                    this.EventsAtStop == input.EventsAtStop ||
                    this.EventsAtStop != null &&
                    input.EventsAtStop != null &&
                    this.EventsAtStop.SequenceEqual(input.EventsAtStop)
                ) && 
                (
                    this.ViolationsOnWayToStop == input.ViolationsOnWayToStop ||
                    this.ViolationsOnWayToStop != null &&
                    input.ViolationsOnWayToStop != null &&
                    this.ViolationsOnWayToStop.SequenceEqual(input.ViolationsOnWayToStop)
                ) && 
                (
                    this.ViolationsAtStop == input.ViolationsAtStop ||
                    this.ViolationsAtStop != null &&
                    input.ViolationsAtStop != null &&
                    this.ViolationsAtStop.SequenceEqual(input.ViolationsAtStop)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.LocationId != null)
                {
                    hashCode = (hashCode * 59) + this.LocationId.GetHashCode();
                }
                if (this.TripId != null)
                {
                    hashCode = (hashCode * 59) + this.TripId.GetHashCode();
                }
                if (this.DeliveryIds != null)
                {
                    hashCode = (hashCode * 59) + this.DeliveryIds.GetHashCode();
                }
                if (this.PickupIds != null)
                {
                    hashCode = (hashCode * 59) + this.PickupIds.GetHashCode();
                }
                if (this.ReportForWayToStop != null)
                {
                    hashCode = (hashCode * 59) + this.ReportForWayToStop.GetHashCode();
                }
                if (this.ReportForStop != null)
                {
                    hashCode = (hashCode * 59) + this.ReportForStop.GetHashCode();
                }
                if (this.EventsOnWayToStop != null)
                {
                    hashCode = (hashCode * 59) + this.EventsOnWayToStop.GetHashCode();
                }
                if (this.EventsAtStop != null)
                {
                    hashCode = (hashCode * 59) + this.EventsAtStop.GetHashCode();
                }
                if (this.ViolationsOnWayToStop != null)
                {
                    hashCode = (hashCode * 59) + this.ViolationsOnWayToStop.GetHashCode();
                }
                if (this.ViolationsAtStop != null)
                {
                    hashCode = (hashCode * 59) + this.ViolationsAtStop.GetHashCode();
                }
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        public IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> Validate(ValidationContext validationContext)
        {
            // LocationId (string) pattern
            Regex regexLocationId = new Regex(@".*[^ ].*", RegexOptions.CultureInvariant);
            if (false == regexLocationId.Match(this.LocationId).Success)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for LocationId, must match a pattern of " + regexLocationId, new [] { "LocationId" });
            }

            // TripId (string) pattern
            Regex regexTripId = new Regex(@".*[^ ].*", RegexOptions.CultureInvariant);
            if (false == regexTripId.Match(this.TripId).Success)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for TripId, must match a pattern of " + regexTripId, new [] { "TripId" });
            }

            yield break;
        }
    }

}
