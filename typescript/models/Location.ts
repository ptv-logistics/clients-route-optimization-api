/* tslint:disable */
/* eslint-disable */
/**
 * Route Optimization
 * With the Route Optimization service you can schedule and optimize the routes of your fleet.
 *
 * The version of the OpenAPI document: 1.11
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { mapValues } from '../runtime';
import type { RoadAccess } from './RoadAccess';
import {
    RoadAccessFromJSON,
    RoadAccessFromJSONTyped,
    RoadAccessToJSON,
    RoadAccessToJSONTyped,
} from './RoadAccess';
import type { TimeInterval } from './TimeInterval';
import {
    TimeIntervalFromJSON,
    TimeIntervalFromJSONTyped,
    TimeIntervalToJSON,
    TimeIntervalToJSONTyped,
} from './TimeInterval';
import type { DepotLocationAttributes } from './DepotLocationAttributes';
import {
    DepotLocationAttributesFromJSON,
    DepotLocationAttributesFromJSONTyped,
    DepotLocationAttributesToJSON,
    DepotLocationAttributesToJSONTyped,
} from './DepotLocationAttributes';
import type { CustomerLocationAttributes } from './CustomerLocationAttributes';
import {
    CustomerLocationAttributesFromJSON,
    CustomerLocationAttributesFromJSONTyped,
    CustomerLocationAttributesToJSON,
    CustomerLocationAttributesToJSONTyped,
} from './CustomerLocationAttributes';
import type { LocationType } from './LocationType';
import {
    LocationTypeFromJSON,
    LocationTypeFromJSONTyped,
    LocationTypeToJSON,
    LocationTypeToJSONTyped,
} from './LocationType';

/**
 * A specific location where goods have to be picked up or delivered, or where vehicles are located. A location is either a depot location or a customer location. Depot locations act as trip delimiters.
 * 
 * See [here](./concepts/locations-transports-and-stops) for more information.
 * @export
 * @interface Location
 */
export interface Location {
    /**
     * A unique ID for this location. This ID can be used to reference the location from other elements, for example from transports or vehicles. The ID does not influence the result.
     * @type {string}
     * @memberof Location
     */
    id: string;
    /**
     * 
     * @type {LocationType}
     * @memberof Location
     */
    type?: LocationType;
    /**
     * The latitude value of the location in degrees (WGS84/EPSG:4326) from south to north.
     * @type {number}
     * @memberof Location
     */
    latitude: number;
    /**
     * The longitude value of the location in degrees (WGS84/EPSG:4326) from west to east.
     * @type {number}
     * @memberof Location
     */
    longitude: number;
    /**
     * 
     * @type {RoadAccess}
     * @memberof Location
     */
    roadAccess?: RoadAccess;
    /**
     * Include the air-line connection between given and matched coordinates in the relation distance and travel time. Will be ignored when **roadAccess** is specified. We will refer to this type of location as an _off-road location_.
     * @type {boolean}
     * @memberof Location
     */
    includeLastMeters?: boolean;
    /**
     * Specifies that this waypoint will be reached at the side of street on which it is located. This is useful to prevent the driver from crossing the street to actually reach the location. Is disabled if an OSM profile is used.
     * @type {boolean}
     * @memberof Location
     */
    matchSideOfStreet?: boolean;
    /**
     * Indicates if vehicle-dependent service time factors are relevant for this location. The factors are typically relevant when the vehicles are (un)loaded by the drivers and may be irrelevant when the vehicles are (un)loaded by the location's staff. If this parameter is set to false, no vehicle-dependent service time factors are taken into account for this location when processing transports.
     * @type {boolean}
     * @memberof Location
     */
    applyVehicleDependentServiceTimeFactor?: boolean;
    /**
     * The opening intervals at this location, each specified by two points in time - the beginning and the end of the interval. Leaving this parameter empty means that the location is always open. Service (pickup or delivery) can only start within one of the opening intervals. If a planning horizon is defined for the request, all opening intervals outside of this horizon are not considered during the route optimization process. If no planning horizon is defined, it is required that the opening intervals of all locations do not span a horizon longer than two weeks.
     * @type {Array<TimeInterval>}
     * @memberof Location
     */
    openingIntervals?: Array<TimeInterval>;
    /**
     * 
     * @type {DepotLocationAttributes}
     * @memberof Location
     */
    depotLocationAttributes?: DepotLocationAttributes;
    /**
     * 
     * @type {CustomerLocationAttributes}
     * @memberof Location
     */
    customerLocationAttributes?: CustomerLocationAttributes;
}



/**
 * Check if a given object implements the Location interface.
 */
export function instanceOfLocation(value: object): value is Location {
    if (!('id' in value) || value['id'] === undefined) return false;
    if (!('latitude' in value) || value['latitude'] === undefined) return false;
    if (!('longitude' in value) || value['longitude'] === undefined) return false;
    return true;
}

export function LocationFromJSON(json: any): Location {
    return LocationFromJSONTyped(json, false);
}

export function LocationFromJSONTyped(json: any, ignoreDiscriminator: boolean): Location {
    if (json == null) {
        return json;
    }
    return {
        
        'id': json['id'],
        'type': json['type'] == null ? undefined : LocationTypeFromJSON(json['type']),
        'latitude': json['latitude'],
        'longitude': json['longitude'],
        'roadAccess': json['roadAccess'] == null ? undefined : RoadAccessFromJSON(json['roadAccess']),
        'includeLastMeters': json['includeLastMeters'] == null ? undefined : json['includeLastMeters'],
        'matchSideOfStreet': json['matchSideOfStreet'] == null ? undefined : json['matchSideOfStreet'],
        'applyVehicleDependentServiceTimeFactor': json['applyVehicleDependentServiceTimeFactor'] == null ? undefined : json['applyVehicleDependentServiceTimeFactor'],
        'openingIntervals': json['openingIntervals'] == null ? undefined : ((json['openingIntervals'] as Array<any>).map(TimeIntervalFromJSON)),
        'depotLocationAttributes': json['depotLocationAttributes'] == null ? undefined : DepotLocationAttributesFromJSON(json['depotLocationAttributes']),
        'customerLocationAttributes': json['customerLocationAttributes'] == null ? undefined : CustomerLocationAttributesFromJSON(json['customerLocationAttributes']),
    };
}

  export function LocationToJSON(json: any): Location {
      return LocationToJSONTyped(json, false);
  }

  export function LocationToJSONTyped(value?: Location | null, ignoreDiscriminator: boolean = false): any {
    if (value == null) {
        return value;
    }

    return {
        
        'id': value['id'],
        'type': LocationTypeToJSON(value['type']),
        'latitude': value['latitude'],
        'longitude': value['longitude'],
        'roadAccess': RoadAccessToJSON(value['roadAccess']),
        'includeLastMeters': value['includeLastMeters'],
        'matchSideOfStreet': value['matchSideOfStreet'],
        'applyVehicleDependentServiceTimeFactor': value['applyVehicleDependentServiceTimeFactor'],
        'openingIntervals': value['openingIntervals'] == null ? undefined : ((value['openingIntervals'] as Array<any>).map(TimeIntervalToJSON)),
        'depotLocationAttributes': DepotLocationAttributesToJSON(value['depotLocationAttributes']),
        'customerLocationAttributes': CustomerLocationAttributesToJSON(value['customerLocationAttributes']),
    };
}

